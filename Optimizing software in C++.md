
# 1. 简介

本手册适用那些想要是软件更快的编程人员和软件开发者.本手册假设读者熟练掌握C++编程语言,并了解编译器是如何工作的.至于选择C++作为本手册基础的原因,将在稍后解释.

本手册的内容基于笔者对编译器和微处理器是如何工作的研究.本手册中的建议是针对x86家族的微处理器,包括intel,AMD 和 VIA的处理器(包括64位版本).x86处理器是Widows, Linux, BSD 和 Mac OS X中使用最多的平台,虽然这些操作系统也可以适用其他微处理器,当然很多设备也使用其他平台和变异语言.

本手册是一个系列五本手册中的第一本:
    1. Optimizing software in C++:An optimization guide for Windows,Linux adn Mac.
    2. Optimizing subroutines in assembly languague:An optimization guide for x86 platforms.
    3. The microarchitecture of Intel,AMD and VIA CPUs:An optimization guide for assembly programmers and compiler makers.
    4. Instruction tables:Lists of instruction latencies,throughputs and micro-operation breakdowns for Intel, AMD and VIA CPUs.
    5. Calling conventions for dirrerent C++ compilers and operating systems.

 这些手册的最新版本可以在[www.anger.org/optimize](www.anger.org/optimize),版权声明将列在手册的最后面.

只用高级语言编写软件的读者只需要阅读本书即可.后续的内容是为了那些想要深入了解 指令集,汇编语言和编译器,处理器微架构的读者准备的.更高层次的优化可以通过使用汇编(for CPU-intensive code?)而获得,这将会在后续的内容中进一步讨论.

请注意到有非常多的人使用到我的优化手册.因此我不可能有时间回答每一个人的问题.所以请不要将你的编程问题发送给我,因为你将得不到任何答案.建议初学者在提高自己的编程经验后,再来尝试手册中所提到的技术.你可以在互联网上的诸多论坛中找到你问题的答案,如果你在相关书籍和手册中找不到答案的话.

我想要感谢那些给我的优化手册发送修正和建议的人,我总是很高兴能够收到相关信息.

## 1.1 优化的代价

如今大学的编程课程在软件开发过程中强调结构化、面向对象、模块化、可重用性、系统化。但是这些要求通常都和优化软件的速度呵呵大小相冲突。

如今，软件导师更经常建议我们函数或者方法的行数应该尽可能的少。但是在几十年前，建议通常是相反的：如果某些功能只会调用一次，那么不要就不要把他们封装在分离的子程序中。软件编写风格的建议变化，是是为软件项目变的越来越大、越来越复杂，需要将注意力集中在软件开发中，而且电脑的性能也越来越强大。

软件结构化开发的高优先级和程序性能的低优先级，首先反映在编程语言和接口框架的选择上。这对于最终的用户来说，这通常是一个缺点，他们不得不购买性能更加强大的计算机，来跟上更大的软件包，即使对于简单的任务，响应时间也长的不能接受，这使得他们感到沮丧。

有时候为了使软件更小更快，有必要在软件开发的高级原则上妥协。本手册讨论了如何在这些要求之间取得合理的平衡。讨论了如何识别和隔离程序中的最关键部分，并将优化工作集中在该部分。讨论了在相对原始的编程风格中，如何克服不自动检查数组越界，无效指针等。讨论了在哪些高级编程结构需要更多的执行时间，哪些需要更少的执行时间。


# 2 选择最优平台

## 2.1 硬件平台的选择

硬件平台的选择相对于过去来说，变成的更不重要了。RISC（精简指令集）和CISC（复杂指令集）处理器、PC和大型主机（mainframes）以及简单处理器（simple processors）和向量处理器（vector processors）之间的区别，变得越来越模糊。拥有CISC指令集的标准PC处理器也包括了RISC核心、向量处理指令（vector processing instruction）、多核、超过以前大型主机的处理速度。

现如今，对于确定任务的硬件平台的选择通常是由诸如价格、兼容性、第二选择（sencond source）和可用的好的开发工具等因素而不是处理能力决定的。在一个网路中连接几个标准PC可能比投资一个大型主机更便宜、更有效率。具有大规模并行向量处理能力的大型超级计算机在科学计算中人有一席之地，但是对于大多数目的来说，标准PC处理器还是首选，应为它们具有更高的性价比。

从技术角度来看，标准PC处理器的的CISC指令集（也称为x86）不是最佳的。这个指令集还在维护，是为了兼容那些在70年代的软件，而当时RAM和硬盘空间是非常稀缺的资源。然而，CISC指令集实际上要比它的名声要好。紧凑的代码使得缓存的效率在缓存资源依旧非常有限的今天更加高效。CISC指令集实际上在缓存资源非常有限的时候比RISC指令集更好。x86指令集最糟糕的问题是缺少寄存器。这个问题在x86指令集的64位扩展中得到了缓解，其中寄存器的数量翻了一倍。

由于无法控制网络资源的响应时间，对于关键的应用程序，不建议使用依赖网络资源的瘦客户机（Thin clients）。

小型手持设备正变得越来越受欢迎，并被用于越来越多的用途，如电子邮件、浏览网页，这些在以前都需要使用一台PC。类似的，我们正看到有越来越多的设备和机器采用嵌入式处理器。我对使用哪些平台和操作系统更高效，没有任具体的建议。但我们需要认识到这些设备通常情况下，内存和计算能力都是要少于PC的，这一点非常重要。因此在这样的系统上节约资源使用比在PC平台上更加重要。然而，通过良好的软件设计，即使在这样的小型设备上，许多应用程序也可以获得良好的表现，这些将在17章进行讨论。

本手册继续标准的PC平台，采用Intel、AMD或者VIA处理器，使用Windows、Linux、BSD或者MAC操作系统。这里给出的很多建议也适用于其它平台，但是都只在PC平台上通过测试。

### 图形加速器

平台的选择明显受任务要求的影响。例如，较大的图形应用编程序最好在具有图形协处理器或者图形加速卡的平台上实现。一些系统也有专门的物理处理器来处理游戏或者动画中的物理运动。

在某些情况下，可以将图形加速卡的高处理能力用于除了图形渲染之外的其他用途。然而，这样的应用具有非常高的系统依赖性。因此如果可移植性非常重要的话，就不推荐这么做。本手册将不会讨论图形处理器。

### 可编程逻辑器件

可编程逻辑器件是一种可以使用硬件描述语言（如VHDL、Verilog）进行编程的芯片。常见的有CPLD和FPGA。编程语言（例如C++）和硬件描述语言的区别是：编程语言定义了一个一系列指令的算法，而硬件描述语言定义了由例如*门*、*触发器*、*多路复用器*、*算术单元*等原件和连接它们的导线组成的硬件电路。硬件描述语言天生就是并行的，因为它定义的是电气连接而不是一系列操作序列。

对于一个复杂的数字操作，可编程逻辑器件通常比微处理器中处理的更快，因为硬件可以特定的目的连接。

在FPGA中实现微处理器作为所谓的软核（soft processor）是可能的。然而这样的处理通常比专用微处理器慢的多，因此它本身并没有什么优势。但是在某些情况下，使用硬件描述语言在同一芯片中定义的软核，执行某些关键应用中的特定指令，是一个非常有效的解决方案。当然将专用微处理器和FPGA集成在同一个芯片中是一个更加强大额解决方案。像这样的混合解决方案已经在一些嵌入式系统中被采用了。

我认为这样类似的解决方案，会有一天在PC处理器中采用。应用程序将可以定义由硬件描述语言编码的应用程序专用指令。这样的处理器除了代码缓存和数据缓存外，还将会有用于硬件描述代码的缓存

## 2.2 微处理器的选择

由于激烈的竞争,不同竞品微处理器的基准性能都非常接近。多核处理器对于那些需要并行运行多个线程的应用程序来说，是好处的。而小型轻量型的低功耗处理器对于非密集型的应用来说也是相当强大的。

一些系统具有图形处理单元，无论是实在图形卡上，亦或是继承在CPU芯片中。这样的单元可以当作协处理器用于一些繁重的图形计算。在某些情况下，也可以将图形处理单元的计算能力用于其它目的，而不是设计它的目的。一些系统还有一个物理处理单元用于计算电脑游戏中物体的运动。

## 2.3 操作系统的选择

x86家族中，所有较新的处理都可以在16-bit、32-bit以及64-bit模式下运行。

16-bit模式在较早的操作系统 *DOS*和*Windows 3.x*中使用。如果程序或者数据的大小超过64 kbytes，这些系统将使用内存分割。这是非常低效率的。现代微处理器没有针对16-bit模式进行优化，一些系统也没有向后兼容16-bit的程序。除了小型嵌入式系统，是不建议编写16-bit程序的。

如今（2013年）32-bit和64-bit的操作系统非常常见，它们在性能上也没有很大的区别。65-bit软件并没有很大的市场，但可以确定的是64-bit系统将主宰未来。

对于一些具很多函数调用和大量使用CPU资源的应用程序来说，可以提升5-10%的性能。如果性能瓶颈在其它地方，32-bit系统和64-bit系统并没有区别。当然使用大量内存的应用程序可以得益于64-bit系统大地址空间。

软件开发者可以在两个版本中选择需要消耗大量内存的软件：为了与现有系统的兼容的32-bit版本，以及具有最佳性能的64-bit版本。

对于32-bit软件，*Windows操作系统*和*Linux操作系统*的性能几乎相当，因为这两个系统使用同样的函数调用约定（*function calling conventions*）。*FreeBSD*和*Open BSD*在软件优化上，几乎所有方面都是相同的。这里说关于*Linux*的所有建议，同样适用于*BSD 系统*。

基于*Intel*的*Mac OS X操作系统*实在*BSD*的基础上开发的，但是编译器默认使用*位置无关代码*（*position-independent code*）和*延迟绑定*，这会降低它的效率。可以通过使用*静态连接*和关闭*位置无关代码*（选项：**-fno-pic**)，来提升性能。

相对于32-bit系统，64-bit系统具有以下几个优点：
1. 两倍的寄存器数量。这样可以在寄存器中而不是内存中存储中间数据和局部变量。
2. 函数参数使用寄存器传递，而不是使用堆栈，这使得函数调用额效率更高。
3. 整数寄存器扩展到64 bits。这样的唯一好处是，应用程序可以使用64-bits整数。
4. 大内存的分配和释放的效率更高。
5. 所有的64-bits CPU和操作系统都支持*SSE2*指令集。
6. 64-bit指令集支持数据的自相关寻址，这使得*位置无关代码*的效率更高。

相对于32-bit系统，64-bit系统具有以下几个缺点：
1. 指针、引用和堆栈入口使用64 bits而不是32 bits，这导致数据缓存的效率更低。
2. 在64 bit模式下，如果装载地址不能保证小于2<sup>31</sup>, 访问静态或者全局数组将会需要几个额外的指令来计算地址。这些额外的成本在64-bits的Windows和Mac程序中可以看到，但是在Linux中很少见。
3. 在大内存模型（代码和数据的大小超过2 Gbytes）中，地址的计算将更加的复杂。虽然这种大内存模型很少能用到。
4. 一些指令的长度，64-bit模式下的长度要比32-bit模式下要长1字节。
5. 一些64-bits编译器要不如它们的32-bits版本。

总的来说，如果程序有很多函数调用、大量大内存快的分配、或者可以利用64-bits整数的优势，那么你可以期待64-bits程序会比32-bits程序跑的略微快一点。当程序使用超过2 gigabytes的数据时，就非常有必要使用64-bits的系统了。

当在64-bits模式下运行时，操作系统之间的相似性将会消失，因为函数的调用约定时不同的。64-bits的*Windows*只允许4个函数参数通过寄存器传递，而64-bits的*Linux*、*BSD*、*Mac*允许通过寄存器传递14个参数（6个整数和8个浮点数）。还有其他的细节使得64-bits*Linux*的函数调用比64-bits*Windows*的效率更高（详见第五册**Calling conventions for different compilers and operating systems**）。一个具有很多函数调用的的程序，有可能在64-bits的*Linux*上，比在64-bits的*Windows*运行的更快。64-bits*Windows* 的这个缺点可以通关是关键函数为内联的或者静态的，或者通过使用可以使进行这个程序优化的编译器来减轻。

## 2.4 编程语言的选择

在开始一个新的软件项目之前，决定哪种编程语言最适合手上的项目是非常重要的。低级语言有利于优化程序执行速度，而高级语言则有利于开发出清晰和结构良好的代码，以及快速和容易的开发用户界面，利用网络资源和数据库的接口等。

最终应用程序的效率取决于编程语言是如何实现的。当代码被编程并翻译成二进制可以行代码时，效率最高。**C++**、**Pascal**以及**Fortran**的绝大多数实现都是通过编译器的。

其它一些编程语言通过解释器实现。代码按原样分发（distribute），运行时逐行解释。例如*JavaScript*、*PHP*、*ASP*以及*UNIX shell script*。解释代码是是非常没有效率的，因为循环的每一次迭代，被一次又一次的解释位一个循环的主体。

有些是通过即时编译（*just-in-time compilation*）实现的。程序代码按照原样存储，一边编译一边执行，例如*Perl*。

一些现代编程语言使用一种中间代码（*byte code*，字节码），源码被编程成中间代码，这是分发的代码。中间代码不能按照原样立即执行，在执行之前，它必须经过第二步的解释或者编译。*Java*的一些实现基于解释器，解释器通过模拟所谓的Jave虚拟机来解释中间代码。最好的Jave虚拟机对于代码的最常用部分使用即时编译。*C#*、*托管C++*以及MicroSoft .Net FrameWork的一些其它一些语言都是基于中间代码的即时编译。

使用中间代码的原因在为了独立于平台且紧凑。使用中间代码的最大缺点是：为了解释或者编译中间代码，用户必须安装庞大的*runtime framework*。而这个*framework*通常需要使用比代码本身多的多的资源。中间代码的另一个是：它增加了额外的抽象层，这使得更加具体的优化更加困难。另一方面，即时编译器可以针对它所运行的CPU进行专门的优化，而在预编译代码中进行特定的优化择更加复杂。

编程语言及其实现的历史揭示了一个曲折的过程，反映了效率、平台独立性和易于开发的等相关冲突的考量。例如，第一台PC有一个*Basic*的解释器，而由于*Basic*解释器实在太慢了，很快就有了*Basic*编译器。如今，最受欢迎的*Basic*版本，是基于中间代码和即时编译的*Visual Basic .NET*。一些早期的*Pascal*实现使用类似今天*Java*的中间代码，但从有了真正的可用的编译器后，该语言获得了显著的欢迎。

从本文的讨论中可以清楚的看到，编程语言的选择需要在效率、可移植性和开发时间等原因进行妥协。当效率很重要的时候，解释类编程语言就不再考虑范围内。而当可移植性和易于开发比速度更重要时，基于中间代码和即使编译的语言可能是一种可行的这种方案。这包括*C#*、*Visual Basic*以及最好的*Java*实现。然而，这些语言的缺点时运行时框非常庞大，而每次运行程序时都必须加载该框架。加载框架和编译程序的时间有可能比执行程序所要的时间还长。而且运行时框架所消耗的资源可能比运行程序本身还多。程序使用这样的框架，对于简单的任务例如按下按钮或者移动鼠标，优势会有难以接受的长响应时间。当速度很关键时就应该避免使用*.Net framework*。

毫无疑问，使用完全编译的代码可以获得最快的执行速度。编译语言包括*C*、*C++*、*D*、*Pascal*、*Fortan*以及其它几种非著名语言。由于一些原因，我更喜欢*C++*。一些非常好的编译器和优化的函数库都支持*C++*。*C++*是一种高级的高级语言（advancd high-level language），具有其他语言中少见的丰富的高级特性。但是*C++*还将低级的*C*语言作为一个自己，因此可以进行低层次的优化。但多数*C++*编译器都支持生成汇编语言，这对于检查编译器对代码的优化成都非常有用。此外，但多数C++编译器允许类似会汇编的函数指令、内联汇编或者易于链接汇编语言模块，但需要最高级别的优化是必要的。*C++*编译器存在于所有主流平台，在这个意义上，*C++*语言是可移植的。*Pascal*相对于*C++*具有很多优势。但是不是很通用。*Fortran*也相当有效率，但是语法相当的过时。

由于有强大的开发工具可用，*C++*开发非常高效。Microsoft Visual Studio是一种非常流行的开发工具。这个工具可以实现*C++*的两种不同实现，直接编译和基于*.NET framework*公共语言运行时的中间代码。显然，当速度很重要时，直接编译的版本更受青睐。

*C++*的一个重要缺点与安全性相关。它没有对数组越界、整数溢出以及无效指针的检查。这些检查的缺席使得代码执行的比那些拥有这些检查的编程语言更快。由于程序规则无法排除这些错误情况，这使得程序员有责任对这些错误进行显示的检查。后面将会有关于这些检查的指导。

当性能优化具有很高优先级时，*C++*绝对时首选的编程语言。与其他编程语言相比，性能上的提升是相当可观的。当性能对最终的用户很重要时，这种性能上的提升，可以很容易证明在开发时间上可能会有细微的提高。

由于其他一些原因，可能需要基于中间代码的高级框架，但是部分代码仍需要仔细优化。在这种情况下，混合实现可能是一个可行的解决档案。代码中最重要的部分可以由基于编译的*C++*或者汇编语言实现，而剩余的部分包括用户界面等，可以使用高级框架实现。被优化的代码部分可以被编译位动态链接库（*DLL*），供其他代码调用。这不是一个最佳的解决档案，因为高级框架任然消耗大量的资源，而这两种代码之间的转换也会产生额外耗费CPU时间的消耗。但是当对时间要求高的部分可以完全包含在DLL中时，这种解决方案也可以显著的提高性能。

另一个值得考虑的选择时*D语言*。*D语言*具有*Java*和*C++*的许多特性，同时避免了很多*C++*的缺点。而且，*D语言*编译成的二进制代码可以与*C*或者*C++*代码链接在译器，但是*D语言*的IDS和编译器没有*C++*的好。

## 2.5 编译器的选择

市面上有几种不同的*C++*编译器可供选择。很难预测哪一个编译器对于一段特定的代码可以做到最佳的优化。每一个编译器都会做一些非常聪明和非常愚蠢的事情。下面将列举一些常见的编译器。
能都非常接近。多核处理器对于那些需要并行运
### 1. Microsoft Visual Studio
这是一个非常友好的编译器，具有许多特性。完整的版本非常昂贵，但是有限制的非商业版本是免费的。Visual Studio可以为. Net框架构建代码，也可以直接编译代码(编译时不使用公共语言运行时，CLR，生成二进制代码)。支持32-bits和64-bits Windows。集成开发环境(IDE)支持多种编程语言的分析和调试。支持多核处理的OpenMP指令。Visual Studio的优化相当好，但它不是最好的优化器。

### 2. Borland/CodeGear/Embarcadero C++ builder
它的IDE具有很多和VS相同的特性，只支持32-bits Windows。不支持最新的指令集。优化做的没有Microsoft、Intel 和Gnu的编译器好。

### 3. Intel C++ compiler (parallel composer)
*Intel*编译器没有它自己的IDE。它可以作为VS和Eclipse的插件。当使用命令行或者make工具时，它也可以作为一个独立的编译器。支持32-bits和64-bits 的*Windows*和*Linux*，也支持基于Intel的*Mac OS* 和 *Itaniumx系统*。Intel编译器支持向量指令、自动矢量化、OpenMP和自动并行化。支持CPU调度，为不同的CPU生成不同版本的代码。在所有的平台上，对于内联汇编都有非常好的支持，使得在*Windows*和*Linux*上使用相同的内联汇编语法成为可能。编译还提供了一些具有最佳优化的数学函数库。

*Intel*编译器最重要的缺点是：它编译的代码在*AMD*和*VIA*的处理器上运行的较慢或者根本不运行。可以通过绕过所谓的CPU调度机制来避免这个问题,该调度机制检查代码是否运行在*Intel CPU*  上。

就从代码可以从它众多的优化特性中受益和可以移植到众多平台上的来说，*Intel*编译器是一个很好额选择。

### 4. Gnu
虽然缺少用户友好，但这是可以使用的最佳编译器之一。它是免费并且开源的。它支持大多数*Linux*发行版本、*BSD*、*Mac OS X*，无论是32-bits的还是64-bits的。支持OpenMP、自动并行化和自动矢量化。Gnu的函数库至今还没有完全优化过。同时支持*AMD*和*Intel*的向量数学库（vector math libraries)。*Gnu C++*编译器在众多的平台上可用，包括32-bits和64-bits的*Linux*、*BSD*、*Windows*以及*Mac*。对于所有的平台来说*Gnu*编译器都是一个非常不错的选择。它是使用命令行运行的独立编译器，但是可以用于很多IDE，包括*Eclipse*、*NetBeans*、*CodeBlocks*和*BloodShed*。

### 5. Clang
*Clang*编译器基于*LLVM*（Low Level Virtual Machine）。它和*Gnu*编译器在很多方面都相似，并与*Gnu*编译器高度兼容。这是*Mac*平台上最常用的编译器，也支持*Linux*和*Windows*平台。对于所有的平台*Clang*编译器都是一个不错的选择。它可以和*Eclipse IDE*一起使用。

### 6. PGI
该编译器支持32-bits和64-bits的*Windows*、*Linux*和*Mac*。之前并行编程、OpenMP和自动矢量化。优化相当不错。但是向量指令的效率很低。

### 7.Digital Mars
这是一个便宜的编译器，用于32-bits *Windows*，包含IDE。优化的不是很好。

### 8. Open Watcom
另一个32-bits的Windows开源编译器。默认情况下不符合标准的调用约定，优化合理。

### 9. Codeplay VectorC
一个32-bits的Windows商业编译器。集成到Microsoft Visual Studio IDE中。显然已经不再更新了。可以做自动矢量化。优化适度。支持三种不同的目标文件格式。

### 评价
TODO：





# 2.6 函数库的选择

