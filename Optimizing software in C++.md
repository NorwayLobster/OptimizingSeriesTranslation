
# 简介

本手册适用那些想要是软件更快的编程人员和软件开发者.本手册假设读者熟练掌握C++编程语言,并了解编译器是如何工作的.至于选择C++作为本手册基础的原因,将在稍后解释.

本手册的内容基于笔者对编译器和微处理器是如何工作的研究.本手册中的建议是针对x86家族的微处理器,包括intel,AMD 和 VIA的处理器(包括64位版本).x86处理器是Widows, Linux, BSD 和 Mac OS X中使用最多的平台,虽然这些操作系统也可以适用其他微处理器,当然很多设备也使用其他平台和变异语言.

本手册是一个系列五本手册中的第一本:
    1. Optimizing software in C++:An optimization guide for Windows,Linux adn Mac.
    2. Optimizing subroutines in assembly languague:An optimization guide for x86 platforms.
    3. The microarchitecture of Intel,AMD and VIA CPUs:An optimization guide for assembly programmers and compiler makers.
    4. Instruction tables:Lists of instruction latencies,throughputs and micro-operation breakdowns for Intel, AMD and VIA CPUs.
    5. Calling conventions for dirrerent C++ compilers and operating systems.

 这些手册的最新版本可以在[www.anger.org/optimize](www.anger.org/optimize),版权声明将列在手册的最后面.

只用高级语言编写软件的读者只需要阅读本书即可.后续的内容是为了那些想要深入了解 指令集,汇编语言和编译器,处理器微架构的读者准备的.更高层次的优化可以通过使用汇编(for CPU-intensive code?)而获得,这将会在后续的内容中进一步讨论.

请注意到有非常多的人使用到我的优化手册.因此我不可能有时间回答每一个人的问题.所以请不要将你的编程问题发送给我,因为你将得不到任何答案.建议初学者在提高自己的编程经验后,再来尝试手册中所提到的技术.你可以在互联网上的诸多论坛中找到你问题的答案,如果你在相关书籍和手册中找不到答案的话.

我想要感谢那些给我的优化手册发送修正和建议的人,我总是很高兴能够收到相关信息.

## 1.1 优化的代价

如今大学的编程课程在软件开发过程中强调结构化、面向对象、模块化、可重用性、系统化。但是这些要求通常都和优化软件的速度呵呵大小相冲突。

如今，软件导师更经常建议我们函数或者方法的行数应该尽可能的少。但是在几十年前，建议通常是相反的：如果某些功能只会调用一次，那么不要就不要把他们封装在分离的子程序中。软件编写风格的建议变化，是是为软件项目变的越来越大、越来越复杂，需要将注意力集中在软件开发中，而且电脑的性能也越来越强大。

软件结构化开发的高优先级和程序性能的低优先级，首先反映在编程语言和接口框架的选择上。这对于最终的用户来说，这通常是一个缺点，他们不得不购买性能更加强大的计算机，来跟上更大的软件包，即使对于简单的任务，响应时间也长的不能接受，这使得他们感到沮丧。

有时候为了使软件更小更快，有必要在软件开发的高级原则上妥协。本手册讨论了如何在这些要求之间取得合理的平衡。讨论了如何识别和隔离程序中的最关键部分，并将优化工作集中在该部分。讨论了在相对原始的编程风格中，如何克服不自动检查数组越界，无效指针等。讨论了在哪些高级编程结构需要更多的执行时间，哪些需要更少的执行时间。


# 2 选择最优平台

## 2.1 硬件平台的选择

硬件平台的选择相对于过去来说，变成的更不重要了。RISC（精简指令集）和CISC（复杂指令集）处理器、PC和大型主机（mainframes）以及简单处理器（simple processors）和向量处理器（vector processors）之间的区别，变得越来越模糊。拥有CISC指令集的标准PC处理器也包括了RISC核心、向量处理指令（vector processing instruction）、多核、超过以前大型主机的处理速度。

现如今，对于确定任务的硬件平台的选择通常是由诸如价格、兼容性、第二选择（sencond source）和可用的好的开发工具等因素而不是处理能力决定的。在一个网路中连接几个标准PC可能比投资一个大型主机更便宜、更有效率。具有大规模并行向量处理能力的大型超级计算机在科学计算中人有一席之地，但是对于大多数目的来说，标准PC处理器还是首选，应为它们具有更高的性价比。

从技术角度来看，标准PC处理器的的CISC指令集（也称为x86）不是最佳的。这个指令集还在维护，是为了兼容那些在70年代的软件，而当时RAM和硬盘空间是非常稀缺的资源。然而，CISC指令集实际上要比它的名声要好。紧凑的代码使得缓存的效率在缓存资源依旧非常有限的今天更加高效。CISC指令集实际上在缓存资源非常有限的时候比RISC指令集更好。x86指令集最糟糕的问题是缺少寄存器。这个问题在x86指令集的64位扩展中得到了缓解，其中寄存器的数量翻了一倍。

由于无法控制网络资源的响应时间，对于关键的应用程序，不建议使用依赖网络资源的瘦客户机（Thin clients）。

小型手持设备正变得越来越受欢迎，并被用于越来越多的用途，如电子邮件、浏览网页，这些在以前都需要使用一台PC。类似的，我们正看到有越来越多的设备和机器采用嵌入式处理器。我对使用哪些平台和操作系统更高效，没有任具体的建议。但我们需要认识到这些设备通常情况下，内存和计算能力都是要少于PC的，这一点非常重要。因此在这样的系统上节约资源使用比在PC平台上更加重要。然而，通过良好的软件设计，即使在这样的小型设备上，许多应用程序也可以获得良好的表现，这些将在17章进行讨论。

本手册继续标准的PC平台，采用Intel、AMD或者VIA处理器，使用Windows、Linux、BSD或者MAC操作系统。这里给出的很多建议也适用于其它平台，但是都只在PC平台上通过测试。

### 图形加速器

平台的选择明显受任务要求的影响。例如，较大的图形应用编程序最好在具有图形协处理器或者图形加速卡的平台上实现。一些系统也有专门的物理处理器来处理游戏或者动画中的物理运动。

在某些情况下，可以将图形加速卡的高处理能力用于除了图形渲染之外的其他用途。然而，这样的应用具有非常高的系统依赖性。因此如果可移植性非常重要的话，就不推荐这么做。本手册将不会讨论图形处理器。

### 可编程逻辑器件

可编程逻辑器件是一种可以使用硬件描述语言（如VHDL、Verilog）进行编程的芯片。常见的有CPLD和FPGA。编程语言（例如C++）和硬件描述语言的区别是：编程语言定义了一个一系列指令的算法，而硬件描述语言定义了由例如*门*、*触发器*、*多路复用器*、*算术单元*等原件和连接它们的导线组成的硬件电路。硬件描述语言天生就是并行的，因为它定义的是电气连接而不是一系列操作序列。

对于一个复杂的数字操作，可编程逻辑器件通常比微处理器中处理的更快，因为硬件可以特定的目的连接。

在FPGA中实现微处理器作为所谓的软核（soft processor）是可能的。然而这样的处理通常比专用微处理器慢的多，因此它本身并没有什么优势。但是在某些情况下，使用硬件描述语言在同一芯片中定义的软核，执行某些关键应用中的特定指令，是一个非常有效的解决方案。当然将专用微处理器和FPGA集成在同一个芯片中是一个更加强大额解决方案。像这样的混合解决方案已经在一些嵌入式系统中被采用了。

我认为这样类似的解决方案，会有一天在PC处理器中采用。应用程序将可以定义由硬件描述语言编码的应用程序专用指令。这样的处理器除了代码缓存和数据缓存外，还将会有用于硬件描述代码的缓存

## 2.2 微处理器的选择

由于激烈的竞争,不同竞品微处理器的基准性能都非常接近。多核处理器对于那些需要并行运行多个线程的应用程序来说，是好处的。而小型轻量型的低功耗处理器对于非密集型的应用来说也是相当强大的。

一些系统具有图形处理单元，无论是实在图形卡上，亦或是继承在CPU芯片中。这样的单元可以当作协处理器用于一些繁重的图形计算。在某些情况下，也可以将图形处理单元的计算能力用于其它目的，而不是设计它的目的。一些系统还有一个物理处理单元用于计算电脑游戏中物体的运动。

## 2.3 操作系统的选择

x86家族中，所有较新的处理都可以在16-bit、32-bit以及64-bit模式下运行。

16-bit模式在较早的操作系统 *DOS*和*Windows 3.x*中使用。如果程序或者数据的大小超过64 kbytes，这些系统将使用内存分割。这是非常低效率的。现代微处理器没有针对16-bit模式进行优化，一些系统也没有向后兼容16-bit的程序。除了小型嵌入式系统，是不建议编写16-bit程序的。

如今（2013年）32-bit和64-bit的操作系统非常常见，它们在性能上也没有很大的区别。65-bit软件并没有很大的市场，但可以确定的是64-bit系统将主宰未来。

对于一些具很多函数调用和大量使用CPU资源的应用程序来说，可以提升5-10%的性能。如果性能瓶颈在其它地方，32-bit系统和64-bit系统并没有区别。当然使用大量内存的应用程序可以得益于64-bit系统大地址空间。

软件开发者可以在两个版本中选择需要消耗大量内存的软件：为了与现有系统的兼容的32-bit版本，以及具有最佳性能的64-bit版本。

对于32-bit软件，*Windows操作系统*和*Linux操作系统*的性能几乎相当，因为这两个系统使用同样的函数调用约定（*function calling conventions*）。*FreeBSD*和*Open BSD*在软件优化上，几乎所有方面都是相同的。这里说关于*Linux*的所有建议，同样适用于*BSD 系统*。

基于*Intel*的*Mac OS X操作系统*实在*BSD*的基础上开发的，但是编译器默认使用*位置无关代码*（*position-independent code*）和*延迟绑定*，这会降低它的效率。可以通过使用*静态连接*和关闭*位置无关代码*（选项：**-fno-pic**)，来提升性能。

相对于32-bit系统，64-bit系统具有以下几个优点：
1. 两倍的寄存器数量。这样可以在寄存器中而不是内存中存储中间数据和局部变量。
2. 函数参数使用寄存器传递，而不是使用堆栈，这使得函数调用额效率更高。
3. 整数寄存器扩展到64 bits。这样的唯一好处是，应用程序可以使用64位整数。
4. 大内存的分配和释放的效率更高。
5. 所有的64位 CPU和操作系统都支持*SSE2*指令集。
6. 64-bit指令集支持数据的自相关寻址，这使得*位置无关代码*的效率更高。

相对于32-bit系统，64-bit系统具有以下几个缺点：
1. 指针、引用和堆栈入口使用64 bits而不是32 bits，这导致数据缓存的效率更低。
2. 在64 bit模式下，如果装载地址不能保证小于2<sup>31</sup>, 访问静态或者全局数组将会需要几个额外的指令来计算地址。这些额外的成本在64位的Windows和Mac程序中可以看到，但是在Linux中很少见。
3. 在大内存模型（代码和数据的大小超过2 Gbytes）中，地址的计算将更加的复杂。虽然这种大内存模型很少能用到。
4. 一些指令的长度，64-bit模式下的长度要比32-bit模式下要长1字节。
5. 一些64位编译器要不如它们的32位版本。

总的来说，如果程序有很多函数调用、大量大内存快的分配、或者可以利用64位整数的优势，那么你可以期待64位程序会比32位程序跑的略微快一点。当程序使用超过2 gigabytes的数据时，就非常有必要使用64位的系统了。

当在64位模式下运行时，操作系统之间的相似性将会消失，因为函数的调用约定时不同的。64位的*Windows*只允许4个函数参数通过寄存器传递，而64位的*Linux*、*BSD*、*Mac*允许通过寄存器传递14个参数（6个整数和8个浮点数）。还有其他的细节使得64位*Linux*的函数调用比64位*Windows*的效率更高（详见第五册**Calling conventions for different compilers and operating systems**）。一个具有很多函数调用的的程序，有可能在64位的*Linux*上，比在64位的*Windows*运行的更快。64位*Windows* 的这个缺点可以通关是关键函数为内联的或者静态的，或者通过使用可以使进行这个程序优化的编译器来减轻。

## 2.4 编程语言的选择

在开始一个新的软件项目之前，决定哪种编程语言最适合手上的项目是非常重要的。低级语言有利于优化程序执行速度，而高级语言则有利于开发出清晰和结构良好的代码，以及快速和容易的开发用户界面，利用网络资源和数据库的接口等。

最终应用程序的效率取决于编程语言是如何实现的。当代码被编程并翻译成二进制可以行代码时，效率最高。**C++**、**Pascal**以及**Fortran**的绝大多数实现都是通过编译器的。

其它一些编程语言通过解释器实现。代码按原样分发（distribute），运行时逐行解释。例如*JavaScript*、*PHP*、*ASP*以及*UNIX shell script*。解释代码是是非常没有效率的，因为循环的每一次迭代，被一次又一次的解释位一个循环的主体。

有些是通过即时编译（*just-in-time compilation*）实现的。程序代码按照原样存储，一边编译一边执行，例如*Perl*。

一些现代编程语言使用一种中间代码（*byte code*，字节码），源码被编程成中间代码，这是分发的代码。中间代码不能按照原样立即执行，在执行之前，它必须经过第二步的解释或者编译。*Java*的一些实现基于解释器，解释器通过模拟所谓的Jave虚拟机来解释中间代码。最好的Jave虚拟机对于代码的最常用部分使用即时编译。*C#*、*托管C++*以及MicroSoft .Net FrameWork的一些其它一些语言都是基于中间代码的即时编译。

使用中间代码的原因在为了独立于平台且紧凑。使用中间代码的最大缺点是：为了解释或者编译中间代码，用户必须安装庞大的*runtime framework*。而这个*framework*通常需要使用比代码本身多的多的资源。中间代码的另一个是：它增加了额外的抽象层，这使得更加具体的优化更加困难。另一方面，即时编译器可以针对它所运行的CPU进行专门的优化，而在预编译代码中进行特定的优化择更加复杂。

编程语言及其实现的历史揭示了一个曲折的过程，反映了效率、平台独立性和易于开发的等相关冲突的考量。例如，第一台PC有一个*Basic*的解释器，而由于*Basic*解释器实在太慢了，很快就有了*Basic*编译器。如今，最受欢迎的*Basic*版本，是基于中间代码和即时编译的*Visual Basic .NET*。一些早期的*Pascal*实现使用类似今天*Java*的中间代码，但从有了真正的可用的编译器后，该语言获得了显著的欢迎。

从本文的讨论中可以清楚的看到，编程语言的选择需要在效率、可移植性和开发时间等原因进行妥协。当效率很重要的时候，解释类编程语言就不再考虑范围内。而当可移植性和易于开发比速度更重要时，基于中间代码和即使编译的语言可能是一种可行的这种方案。这包括*C#*、*Visual Basic*以及最好的*Java*实现。然而，这些语言的缺点时运行时框非常庞大，而每次运行程序时都必须加载该框架。加载框架和编译程序的时间有可能比执行程序所要的时间还长。而且运行时框架所消耗的资源可能比运行程序本身还多。程序使用这样的框架，对于简单的任务例如按下按钮或者移动鼠标，优势会有难以接受的长响应时间。当速度很关键时就应该避免使用*.Net framework*。

毫无疑问，使用完全编译的代码可以获得最快的执行速度。编译语言包括*C*、*C++*、*D*、*Pascal*、*Fortan*以及其它几种非著名语言。由于一些原因，我更喜欢*C++*。一些非常好的编译器和优化的函数库都支持*C++*。*C++*是一种高级的高级语言（advancd high-level language），具有其他语言中少见的丰富的高级特性。但是*C++*还将低级的*C*语言作为一个自己，因此可以进行低层次的优化。但多数*C++*编译器都支持生成汇编语言，这对于检查编译器对代码的优化成都非常有用。此外，但多数C++编译器允许类似会汇编的函数指令、内联汇编或者易于链接汇编语言模块，但需要最高级别的优化是必要的。*C++*编译器存在于所有主流平台，在这个意义上，*C++*语言是可移植的。*Pascal*相对于*C++*具有很多优势。但是不是很通用。*Fortran*也相当有效率，但是语法相当的过时。

由于有强大的开发工具可用，*C++*开发非常高效。Microsoft Visual Studio是一种非常流行的开发工具。这个工具可以实现*C++*的两种不同实现，直接编译和基于*.NET framework*公共语言运行时的中间代码。显然，当速度很重要时，直接编译的版本更受青睐。

*C++*的一个重要缺点与安全性相关。它没有对数组越界、整数溢出以及无效指针的检查。这些检查的缺席使得代码执行的比那些拥有这些检查的编程语言更快。由于程序规则无法排除这些错误情况，这使得程序员有责任对这些错误进行显示的检查。后面将会有关于这些检查的指导。

当性能优化具有很高优先级时，*C++*绝对时首选的编程语言。与其他编程语言相比，性能上的提升是相当可观的。当性能对最终的用户很重要时，这种性能上的提升，可以很容易证明在开发时间上可能会有细微的提高。

由于其他一些原因，可能需要基于中间代码的高级框架，但是部分代码仍需要仔细优化。在这种情况下，混合实现可能是一个可行的解决档案。代码中最重要的部分可以由基于编译的*C++*或者汇编语言实现，而剩余的部分包括用户界面等，可以使用高级框架实现。被优化的代码部分可以被编译位动态链接库（*DLL*），供其他代码调用。这不是一个最佳的解决档案，因为高级框架任然消耗大量的资源，而这两种代码之间的转换也会产生额外耗费CPU时间的消耗。但是当对时间要求高的部分可以完全包含在DLL中时，这种解决方案也可以显著的提高性能。

另一个值得考虑的选择时*D语言*。*D语言*具有*Java*和*C++*的许多特性，同时避免了很多*C++*的缺点。而且，*D语言*编译成的二进制代码可以与*C*或者*C++*代码链接在译器，但是*D语言*的IDS和编译器没有*C++*的好。

## 2.5 编译器的选择

市面上有几种不同的*C++*编译器可供选择。很难预测哪一个编译器对于一段特定的代码可以做到最佳的优化。每一个编译器都会做一些非常聪明和非常愚蠢的事情。下面将列举一些常见的编译器。
能都非常接近。多核处理器对于那些需要并行运
### Microsoft Visual Studio
这是一个非常友好的编译器，具有许多特性。完整的版本非常昂贵，但是有限制的非商业版本是免费的。Visual Studio可以为. Net框架构建代码，也可以直接编译代码(编译时不使用公共语言运行时，CLR，生成二进制代码)。支持32位和64位 Windows。集成开发环境(IDE)支持多种编程语言的分析和调试。支持多核处理的OpenMP指令。Visual Studio的优化相当好，但它不是最好的优化器。

### Borland/CodeGear/Embarcadero C++ builder
它的IDE具有很多和VS相同的特性，只支持32位 Windows。不支持最新的指令集。优化做的没有Microsoft、Intel 和Gnu的编译器好。

### Intel C++ compiler (parallel composer)
*Intel*编译器没有它自己的IDE。它可以作为VS和Eclipse的插件。当使用命令行或者make工具时，它也可以作为一个独立的编译器。支持32位和64位 的*Windows*和*Linux*，也支持基于Intel的*Mac OS* 和 *Itaniumx系统*。Intel编译器支持向量指令、自动矢量化、OpenMP和自动并行化。支持CPU调度，为不同的CPU生成不同版本的代码。在所有的平台上，对于内联汇编都有非常好的支持，使得在*Windows*和*Linux*上使用相同的内联汇编语法成为可能。编译还提供了一些具有最佳优化的数学函数库。

*Intel*编译器最重要的缺点是：它编译的代码在*AMD*和*VIA*的处理器上运行的较慢或者根本不运行。可以通过绕过所谓的CPU调度机制来避免这个问题,该调度机制检查代码是否运行在*Intel CPU*  上。

就从代码可以从它众多的优化特性中受益和可以移植到众多平台上的来说，*Intel*编译器是一个很好额选择。

### Gnu
虽然缺少用户友好，但这是可以使用的最佳编译器之一。它是免费并且开源的。它支持大多数*Linux*发行版本、*BSD*、*Mac OS X*，无论是32位的还是64位的。支持OpenMP、自动并行化和自动矢量化。Gnu的函数库至今还没有完全优化过。同时支持*AMD*和*Intel*的向量数学库（vector math libraries)。*Gnu C++*编译器在众多的平台上可用，包括32位和64位的*Linux*、*BSD*、*Windows*以及*Mac*。对于所有的平台来说*Gnu*编译器都是一个非常不错的选择。它是使用命令行运行的独立编译器，但是可以用于很多IDE，包括*Eclipse*、*NetBeans*、*CodeBlocks*和*BloodShed*。

### Clang
*Clang*编译器基于*LLVM*（Low Level Virtual Machine）。它和*Gnu*编译器在很多方面都相似，并与*Gnu*编译器高度兼容。这是*Mac*平台上最常用的编译器，也支持*Linux*和*Windows*平台。对于所有的平台*Clang*编译器都是一个不错的选择。它可以和*Eclipse IDE*一起使用。

### PGI
该编译器支持32位和64位的*Windows*、*Linux*和*Mac*。之前并行编程、OpenMP和自动矢量化。优化相当不错。但是向量指令的效率很低。

### 7.Digital Mars
这是一个便宜的编译器，用于32位 *Windows*，包含IDE。优化的不是很好。

### Open Watcom
另一个32位的Windows开源编译器。默认情况下不符合标准的调用约定，优化合理。

### Codeplay VectorC
一个32位的Windows商业编译器。集成到Microsoft Visual Studio IDE中。显然已经不再更新了。可以做自动矢量化。优化适度。支持三种不同的目标文件格式。

### 总结
在没有IDE的情况下，所有这些编译器都可以作为命令行版本使用。商业编译器有免费的试用版本提供。

在*Linux*平台上，通常可以混合来自不同编译器的目标文件（*Object File*），在某些情况下，也可以在Windows平台上也可以。*Microsoft*和*Intel*的Windows编译器在目标文件级别上完全兼容，而*Digital Mars*编译器基本上与它们兼容。*Embarcadero*、*Codeplay*和*Watcom*编译器在目标文件级别上与其他编译器不兼容。

为了良好的代码性能，我建议在Unix应用程序中使用Gnu、Clang或Intel编译器，在Windows应用程序中使用Gnu、Clang、Intel或Microsoft编译器。如果您希望您的代码在AMD微处理器上高效运行，请不要使用Intel编译器。

编译器的选择可能在某些情况下由遗留代码兼容的要求，IDE具体的参数选择，调试工具，简单的GUI开，数据库集成web应用程序集成，混合语言编程等决定。如果所选择的编译器不提供最好的优化，在这种情况下，最关键的模块使用不同的编译器可能是非常有帮助的。在大多数情况下，如果包含必要的库文件，那么由*Intel*编译器生成的目标文件可以毫无问题地链接到使用*Microsoft*或*Gnu*编译器生成的项目中。或者，使用最好的编译器生成DLL，并从使用另一个编译器构建的项目中调用它。





# 2.6 函数库的选择

有些应用程序将大部分执行时间花在执行库函数上。Tim-econsuming库函数通常属于以下类别之一：
1. 文件输入/输出
2. 图形和声音处理
3. 内存和字符串操作
4. 数学函数
5. 加密，解密和数据压缩

大多数编译器都包含用于这些目的的标准库。不幸的是，标准库并不总是完全优化的。

库函数通常是许多用户在许多不同应用程序中使用的一小段代码。因此，与优化特定于应用程序的代码相比，值得在优化库函数方面投入更多的精力。最好的函数库是使用*汇编语言*和*自动cpu调度* 以及最新的*指令集扩展*高度优化的。

如果分析显示库函数在某个特定应用程序占用了大量CPU时间，或者如果这是显而易见的，那么可以通过使用不同的函数库来显著提高性能。如果应用程序在库函数中花费了大部分时间，那么除了寻找最有效的库和节省库函数调用之外，可能不需要优化其他任何地方。建议尝试不同的库，看看哪个最好。

下面将讨论一些常见的函数库。还有许多用于特殊目的的库。

## Microsoft
微软编译器自带。有些函数优化得很好，有些则没有。支持32位和64位 *Windows*。

## Borland / CodeGear / Embarcadero
*Borland C++ builder*自带。未针对*SSE2*和后续指令集进行优化。只支持32位 *Windows*。

## Gnu
*Gnu*编译器自带的。没有像编译器本身优化的好。64位版本比32位版本好。Gnu编译器经常插入内置代码，而不是最常见的内存和字符串指令。内置代码不是最优的。使用选项*-fno-builtin*使用库版本替代内置版本。*Gnu*库支持32位和64位*Linux*和*BSD*。Windows版本目前还不是最新的。

## Mac
*Mac OS X* （*Darwin*）* Gnu*编译器中包含的库是*Xnu*项目的一部分。在所谓的**commpage**中，操作系统内核中包含了一些最重要的函数。这些功能针对*Intel Core*和稍后的*Intel*处理器版本进行了高度优化。*AMD*处理器和早期的英特尔处理器根本不被支持。只能在Mac平台上运行。

## Intel
*Intel*编译器包含标准函数库。还有一些特殊用途的库，如“*Intel Math Kernel Library*”和“*"ntegrated Performance Primitives*”。这些函数库针对大型数据集进行了高度优化。然而，英特尔的库在AMD和VIA处理器上并不能总是运行良好。有关解释和可能的解决方法，请参见后面的章节。支持所有x86和x86-64平台。

## AMD
*AMD*数学核心库包含优化的数学函数。它也适用于英特尔处理器。性能不如*Intel*库。支持32位和64位*Windows*和*Linux*。

## AsmLib
我自己的函数库是为了演示而创建的。可以从[www.agner.org/optimize/asmlib.zip](www.agner.org/optimize/asmlib.zip)获得。目前包括内存和字符串函数的优化版本，以及其他一些很难在其他地方找到的函数。在最新的处理器上运行时，比大多数其他库都要快。支持所有x86和x86-64平台。

<center>

|                  Test                  |   Processor    | Microsoft | CodeGear | Intel | Mac  | Gnu <br> 32-bits</br> | Gnu <br>32-bits</br>-fno-builtin | Gnu <br>64-bits</br>-fno-builtin | Asmlib |
| :------------------------------------: | :------------: | :-------: | :------: | :---: | :--: | --------------------- | -------------------------------- | -------------------------------- | ------ |
| `memcpy`16kB <br>aligned operands</br> |  Intel Core 2  |   0.12    |   0.18   | 0.12  | 0.11 | 0.18                  | 0.18                             | 0.18                             | 0.11   |
|  `memcpy`16kB <br>unaligned op.</br>   |  Intel Core 2  |   0.63    |   0.75   | 0.18  | 0.11 | 1.21                  | 0.57                             | 0.44                             | 0.12   |
| `memcpy`16kB <br>aligned operands</br> | AMD Opteron K8 |   0.24    |   0.25   | 0.24  | n.a. | 1.00                  | 0.25                             | 0.28                             | 0.22   |
|  `memcpy`16kB <br>unaligned op.</br>   | AMD Opteron K8 |   0.38    |   0.44   | 0.40  | n.a. | 1.00                  | 0.35                             | 0.29                             | 0.28   |
|           `strlen`128 bytes            |  Intel Core 2  |   0.77    |   0.89   | 0.40  | 0.30 | 4.5                   | 0.82                             | 0.59                             | 0.27   |
|           `strlen`128 bytes            | AMD Opteron K8 |   1.09    |   1.25   | 1.61  | n.a. | 2.23                  | 0.95                             | 0.6                              | 1.19   |


表2.1. 不同函数库性能对比
</center>
表中的数字是每字节数据的核心时钟周期(低数字意味着良好的性能)。对齐的操作数意味着源和目标的地址都可以被16整除。
<u>用于测试库的版本（不是最新的）</u>
* Microsoft Visual studio 2008, v. 9.0
* CodeGear Borland bcc, v. 5.5
* Mac: Darwin8 g++ v 4.0.1.
* Asmlib: v. 2.00
* Intel C++ compiler, v. 10.1.020.  使用库*libircmt.lib* 中的 `_intel_fast_memcpy` 和 `__intel_new_strlen`函数。函数名没有文档。

# 2.7 用户界面框架的选择

典型软件项目中的大多数代码都进入用户界面。不需要大量计算的应用程序很可能在用户界面上花费的CPU时间比在程序的基本任务上花费的还要多。

程序员很少从头开始编写自己的图形用户界面。这不仅浪费了程序员的时间，也给最终用户带来了不便。出于可用性的考虑，菜单、按钮、对话框等应该尽可能地标准化。程序员可以使用操作系统附带的标准用户界面元素或编译器和开发工具附带的库。

*Microsoft Foundation Classes*是一个流行的*Windows*  *C++*用户界面库(**MFC**)。与之竞争的产品是Borland现已停止继续维护的*Object  Windows Library*（**OWL**）。*Linux*系统有几个可用的图形界面框架。用户界面库可以作为运行时DLL或静态库链接。除非多个应用程序同时使用同一个DLL，运行时DLL比静态库占用更多的内存资源。

 用户界面库可能比应用程序本身更大，需要更多的时间来加载。一个轻量级的替代方案是*Windows Template Library*（**WTL**）。*WTL*应用程序通常比*MFC*应用程序更快、更紧凑。由于糟糕的文档、缺乏高级开发工具，WTL应用程序可能会花费更多的时间去开发。

通过放弃使用图形用户界面并使用控制台模式程序，可以获得最简单的用户界面。控制台模式程序的输入通常在命令行或输入文件中指定。输出到控制台或文件。控制台模式的程序是快速、紧凑和易于开发的。方便移植到不同的平台，因为它不依赖于系统特定的图形界面调用。可用性可能很差，因为它缺少图形用户界面的自解释菜单。控制台模式程序对于从其他应用程序(如实现工具库)调用非常有用。

结论是，用户界面框架的选择必须是开发时间、可用性、程序紧凑性和运行时间之间的折衷。没有一个通用的解决方案对所有应用程序都是最好的。

# 2.8 克服C++语言的缺点

虽然c++在优化方面有很多优点，但它也有一些缺点，这使得开发人员不得不选择其他编程语言。本节将讨论在选择*C++*进行优化时如何克服这些缺点。

<u>可移植性</u>
===
c++是完全可移植的，因为它的语法在所有主要平台上都是完全标准化和受支持的。然而，c++也是一种允许直接访问硬件接口和系统调用的语言。这些当然是系统特有的。为了方便在平台之间进行移植，建议将用户界面代码和其他系统特定部分放在一个单独的模块中，并将代码的任务特定部分(应该是系统独立的)放在另一个模块中。

整数的大小和其他硬件相关细节取决于硬件平台和操作系统。详情见第29页（TODO）。

<u>开发时间</u>
===
一些开发人员认为特定的编程语言和开发工具比其他语言和开发工具使用起来更快。虽然有些区别仅仅是习惯的问题，但确实有些开发工具具有强大的功能，可以自动完成许多琐碎的编程工作。通过一致的模块化和可重用类，可以降低C++项目的开发时间并提高可维护性。

<u>安全性</u>
===
*C++*语言最严重的问题与安全性有关。标准*C++*的实现没有检查数组边界违规和无效指针。这是*C++*程序中常见的错误来源，也是黑客可能的攻击点。有必要遵守某些编程原则，以防止在涉及安全性的程序中出现此类错误。

无效指针的问题可以通过使用引用代替指针，通过初始化指针为0，通过将指针指向的对象无效时将指针设置为0来避免，还可以通过避免指针算术和指针类型转换来避免。通常使用指针的链表和其他数据结构可以使用更高效的容器类模板替代，如第95页（TODO：）所述。避免使用`scanf`函数。

数组越界可能是*C++*程序错误的最常见原因。对数组边界外的赋值操作，可能会重写其他变量，更糟糕的是，它可能会重写定义数组的函数的返回地址。这会导致各种奇怪和意想不到的行为。数组通常用作存储文本或输入数据的缓冲区。缺少对输入数据缓冲区溢出的检查是黑客经常利用的一个常见错误。

防止此类错误的一个好方法是使用经过良好测试的容器类来替换数组。标准模板库（**STL**）是此类容器类的一个有用来源。不幸的是，许多标准容器类以一种低效的方式来使用动态内存分配。有关如何避免动态内存分配的示例，请参见第92页（TODO：）。有关高效容器类的讨论，请参见第95页（TODO：）。[www.agner.org/optimize/cppexamples.zip](www.agner.org/optimize/cppexamples.zip)上本手册的附录含带有边界检查和各种高效容器类的数组示例。

文本字符串尤其有问题，因为字符串的长度可能没有特定的限制。在字符数组中存储字符串的旧式*C*风格方法快速有效，但不安全，除非在存储之前检查每个字符串的长度。这个问题的标准解决方案是使用*string*类，例如**string**或**CString**。这是安全且灵活的，但在大型应用程序中效率非常低。每次创建或修改字符串时，string类都会分配一个新的内存块。这可能会导致内存碎片化，并涉及堆管理和垃圾收集的高开销成本。一个不影响安全性的更有效的解决方案是将所有字符串存储在一个内存池中。有关如何在内存池中存储字符串，请参见附录中的示例（[参见www.agner.org/optimize/cppexamples.zip](www.agner.org/optimize/cppexamples.zip)）。

整数溢出是另一个安全问题。官方的*C*标准说，在溢出的情况下，有符号整数的行为是“未定义的”。这允许编译器忽略溢出或假设它没有发生。在*Gnu*编译器的情况下，不发生带符号整数溢出的假设的不幸后果是，它允许编译器优化掉溢出检查。对于这个问题，有许多可能的补救措施：（1）在溢出前进行，（2）使用无符号整数——它们是保证回绕（*wrap around*），（3）使用选项`-ftrapv`捕获整数溢出,但这是非常低效的，（4）使用选项`-Wstrict-overflow = 2`，对这样的优化进行警告，(5)使用选项`-fwrapv`或`-fno-strict-overflow`明确定义溢出行为。

在代码中速度很重要的关键部分，您可能会偏离上述安全建议。如果不安全的代码仅限于经过良好测试的函数、类、模板或模块，并且与程序的其余部分有良好定义的接口，那么这是被允许的。


# 3 找到消耗时间最多的地方

## 3.1 一个时钟周期是多少？
在本手册中，我使用CPU时钟周期而不是秒或微秒作为时间度量单位。这是因为不同计算机有不同的速度。今天，如果我写下某事需要10μs,那么在下一代的电脑，它可能只需要5μs，而我的手册将很快被淘汰。但是如果我写下某事需要10个时钟周期，即使CPU时钟频率加倍，那么它仍然需要10个时钟周期。

时钟周期的长度是时钟频率的倒数。例如，如果时钟频率是2 GHz，那么时钟周期的长度是：

<center>

```mathjax
$$
\frac 1 2GHz=5ns
$$
```
</center>

一台计算机上的时钟周期并不总是可以与另一台计算机上的时钟周期相比较。奔腾4 （*NetBurst*） CPU的被设计为具有比其他CPU更高的时钟频率，但是总的来说，在执行同一段代码时，它比其他CPU耗费更多的时钟周期。

假设程序中的一个循环重复1000次，循环中有100个浮点运算（加法、乘法等）。如果每个浮点运算需要5个时钟周期,然后我们可以大致估计,循环将1000 * 100 * 5 * 0.5 ns = 250μs 2 GHz CPU。我们应该尝试优化这个循环吗?当然不！250μs小于1/50的时间刷新屏幕。用户不可能看到延迟。但是在这个循环中还存在另一个循环，另一个循环也重复1000次，那么我们估计计算时间为250毫秒。这种延迟的时间足够长，足以引起注意，但也不够长，足以令人厌烦。我们可能决定做一些测量，看看我们的估计是否正确，或者计算时间是否实际超过250毫秒。如果响应时间太长，用户实际上必须等待结果，那么我们将考虑是否有可以改进的地方。

## 3.2 使用分析器查找热点（*hot spots*）
在开始优化任何东西之前，必须先识别程序的关键部分。在一些程序中，超过99%的时间花在最内部的循环中进行数学计算。在其他程序中，99%的时间花在读取和写入数据文件上，只有不到1%的时间花在实际操作这些数据上。优化重要部分的代码，而不是优化只占总时间的一小部分代码，这一点非常重要。优化代码中不太重要的部分不仅会浪费时间，还会使代码不太清晰，更难于调试和维护。

大多数编译器包都包含一个分析器，它可以告诉每个函数被调用的次数和时间。也有第三方剖析器，如*AQtime*、*Intel VTune*和*AMD CodeAnalyst*。

有几种不同的分析方法:
* 植入：编译器在每次函数调用时插入额外的代码，以计算调用函数的次数和时间。
* 调试：分析器在每个函数或每一行代码中插入临时调试断点。
* 基于时间的采样：分析器告诉操作系统生成一个中断，例如每毫秒一次。分析器计算在程序的每个部分中发生中断的次数。这不需要修改被测程序，但可靠性较差。
* 基于事件的采样：分析器告诉CPU在某些事件上生成中断，例如每次发生1000次缓存丢失。这使得查看程序的哪个部分有最多的缓存丢失、分支错误预测、浮点异常等等成为可能。基于事件的采样需要基于CPU的分析其。对于Intel CPU使用*Intel VTune*，对于AMD CPU使用*AMD CodeAnalyst*。

不幸的是，分析器通常是不可靠的。它们有时会给出误导的结果，或者完全因为技术问题而失败。分析器的一些常见问题是：
* 粗糙的时间测量。如果时间是以毫秒级的分辨率测量的，并且关键函数的执行需要几微秒，那么测量可能变得不精确，或者干脆为零。
* 执行时间过短或过长。如果被测程序在短时间内完成，那么采样生成的数据太少，无法进行分析。如果程序执行时间太长，那么采样生成的数据太多，超出分析器的分析能力。
* 等待用户输入。许多程序将大部分时间用于等待用户输入或网络资源。这个时间包含在分析文件中。为了使分析可行，可能需要修改程序以使用一组测试数据而不是用户输入。
* 来自其他过程的干扰。分析器不仅测量被测试程序中所花费的时间，而且还测量在同一台计算机上运行的所有其他进程（包括分析器本身）所使用的时间。
* 函数地址在优化的程序中是模糊的。分析器通过地址识别程序中的任何热点，并尝试将这些地址转换为函数名。但是，高度优化的程序经常以这样一种方式重新组织:函数名和代码地址之间没有明确的对应关系。内联函数的名称对于分析器可能根本不可见。其结果将是关于哪些功能花费的时间最多的误导性报告。
* 使用调试版本的代码。一些分析器要求您正在测试的代码包含调试信息，以便识别单个函数或代码函数。代码的调试版本没有优化。
* 在CPU内核之间跳转。进程或线程不一定停留在多核CPU上的同一处理器内核中，但事件计数器可以。这导致在多个CPU内核之间跳转的线程的事件计数没有意义。您可能需要通过设置线程关联掩码将线程锁定到特定的CPU内核。
* 再现性不好。程序执行中的延迟可能是由不可重现的随机事件引起的。诸如任务切换和垃圾收集之类的事件可以在随机时间发生，这使得程序的某些部分看起来比正常情况下花费的时间更长。

有多种方法可以替代分析器。一个简单的替代方法是在调试器中运行程序，并在程序运行时按下**break**。如果有一个热点，占用90%的CPU时间，那么中断有90%的机会发生在这个热点。重复中断几次可能足以确定一个热点。在调试器中使用调用堆栈来识别热点周围的情况。

有时，识别性能瓶颈的最佳方法是将度量工具直接放入代码中，而不是使用现成的分析器。这并不能解决与概要分析相关的所有问题，但通常会提供更可靠的结果。如果您不满意分析器的工作方式，那么您可以将所需的测量仪器插入程序本身。您可以添加计数器变量来计算程序的每个部分执行了多少次。此外，您可以读取程序中每个最重要或关键部分前后的时间，以度量每个部分所花费的时间。有关此方法的进一步讨论，请参阅第157页（TODO）。

您的测量代码应该包含`#if`指令，以便在代码的最终版本中禁用它。在代码中插入自己的分析工具是z在程序开发过程中跟踪程序性能的一种非常有用的方法。

如果时间间隔很短，时间测量可能需要很高的分辨率。在Windows中，您可以使用`GetTickCount`或`QueryPerformanceCounter`函数获得毫秒级的分辨率。使用CPU中的时间戳计数器可以获得更高的分辨率，它以CPU时钟频率计数（在Windows中: `__rdtsc()`）。

如果线程在不同的CPU内核之间跳转，时间戳计数器将失效。在时间度量期间，您可能必须将线程固定到特定的CPU核心，以避免这种情况。（在*Windows*中是`SetThreadAffinityMask`，在*Linux*中是`sched_setaffness`)。

程序应该用一组真实的测试数据进行测试。测试数据应该具有一个典型的随机性，以便获得真实数量的缓存丢失和分支错误预测。

当发现程序中最耗时的部分时，重要的是将优化工作集中在耗时的部分上。关键代码片段可以使用第157页中（TODO）描述的方法进行进一步测试和研究。

分析器对于查找与CPU密集型代码相关的问题最有用。但是许多程序在加载文件或访问数据库、网络和其他资源时所花费的时间比算术运算要多。下面几节将讨论最常见的时间消耗器。

# 3.3